/*
 * This file is auto-generated using abi-gen. Any changes will be reverted
 */

import { isDefined, bindNestedAll } from "@joincivil/utils";
import BigNumber from "bignumber.js";

import { createTwoStepSimple } from "../../utils/contracts";
import { BaseMultisigProxy, MultisigProxyTransaction } from "../../multisig/basemultisigproxy";
import { Contract } from "../../interfaces/contract";
import { OwnableContract } from "../../interfaces/ownable";
import { EthApi } from "../../../utils/ethapi";
import { TxData } from "../../../types";

// TODO(ritave): Abi-Gen doesn't support lowercase contractName so we can't
//               import the Contract wrappers, we're using generics instead
//               This means calls to instance are untyped inside are using (this: any) type
export class {{contractName}}MultisigProxy extends BaseMultisigProxy {
  /**
   * Creates a multisig wrapper around a contract
   * @param ethApi Web3 API
   * @param instance Contract we are wrapping
   * @param multisigAddress (optional) Address of multisig wallet - if not supplied, will check if contract is owned by a multisig wallet and use that instead
   */
  public static async create(
    ethApi: EthApi,
    instance: Contract | OwnableContract,
    multisigAddress?: string,
  ): Promise<{{contractName}}MultisigProxy> {
    let contractOwner;
    {{!-- TODO(tobek): Hack here using `Contract | OwnableContract` for contract instance and then casting `instance` and populating `contractOwner` only as needed. Newsroom expects `OwnableContract` but others neither have one nor need one. A more elegant solution be to subclass `BaseMultisigProxy` with a new `BaseMultisigNewsroomProxy` and extend the appropriate class from this template, but without the ability to test equality in handlebars that would require a duplicate template or some solution with partials, but before I go that route I want to confirm this approach actually makes sense. --}}
    if ((instance as OwnableContract).owner) {
      contractOwner = await (instance as OwnableContract).owner.callAsync();
    }
    const proxy = new {{contractName}}MultisigProxy(ethApi, instance, contractOwner);
    await proxy.resolveMultisig(multisigAddress);
    return proxy;
  }

{{#each methods}}
  {{^this.constant}}
  {{> proxy_tx contractName=../contractName}}
  {{/this.constant}}
{{/each}}

  private constructor(
    ethApi: EthApi,
    instance: Contract | OwnableContract,
    contractOwner?: string,
  ) {
    super(ethApi, instance, contractOwner);
    bindNestedAll(this, ["constructor", "instance", "multisig", "ethApi", "contractOwner"]);
  }
}
